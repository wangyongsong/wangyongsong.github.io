(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{527:function(v,_,e){"use strict";e.r(_);var o=e(3),t=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器-browser"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器-browser"}},[v._v("#")]),v._v(" 浏览器 (Browser)")]),v._v(" "),e("ul",[e("li",[v._v("主流浏览器：\n"),e("ul",[e("li",[e("code",[v._v("Opera")]),v._v(" 挪威Opera Software ASA公司旗下的浏览器("),e("code",[v._v("Blink")]),v._v("内核)")]),v._v(" "),e("li",[e("code",[v._v("Chrome")]),v._v(" Google旗下的浏览器("),e("code",[v._v("Blink")]),v._v("内核)")]),v._v(" "),e("li",[e("code",[v._v("Safari")]),v._v(" Apple旗下的浏览器("),e("code",[v._v("Webkit")]),v._v("内核)")]),v._v(" "),e("li",[e("code",[v._v("Firefox")]),v._v(" Mozilla公司旗下浏览器("),e("code",[v._v("Gecko")]),v._v("内核)")]),v._v(" "),e("li",[e("code",[v._v("Microsoft Edge")]),v._v(" Microsoft旗下浏览器("),e("code",[v._v("Blink")]),v._v("内核)")]),v._v(" "),e("li",[e("code",[v._v("Internet Explorer(IE)")]),v._v(" Microsoft旗下浏览器("),e("code",[v._v("Trident")]),v._v("内核) -- 逐渐淡化")])])])]),v._v(" "),e("h2",{attrs:{id:"浏览器的加载过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的加载过程"}},[v._v("#")]),v._v(" 浏览器的加载过程")]),v._v(" "),e("ul",[e("li",[v._v("向浏览器输入网址")]),v._v(" "),e("li",[v._v("浏览器根据 DNS 服务器得到域名的 IP 地址")]),v._v(" "),e("li",[v._v("向这个 IP 的机器发送 HTTP 请求")]),v._v(" "),e("li",[v._v("服务器收到、处理并返回 HTTP 请求")]),v._v(" "),e("li",[v._v("浏览器接收到服务器返回的内容")])]),v._v(" "),e("h2",{attrs:{id:"浏览器渲染过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程"}},[v._v("#")]),v._v(" 浏览器渲染过程")]),v._v(" "),e("img",{attrs:{src:"/assets/img/browser1.jpeg"}}),v._v(" "),e("p",[v._v("解析"),e("code",[v._v("HTML")]),v._v("，生成"),e("code",[v._v("DOM树")]),v._v("，解析"),e("code",[v._v("CSS")]),v._v("，生成"),e("code",[v._v("CSSOM树")])]),v._v(" "),e("p",[v._v("将"),e("code",[v._v("DOM树")]),v._v("和"),e("code",[v._v("CSSOM树")]),v._v("结合，生成渲染树("),e("code",[v._v("Render Tree")]),v._v(")")]),v._v(" "),e("p",[e("code",[v._v("Layout")]),v._v("(回流):根据生成的渲染树，进行回流("),e("code",[v._v("Layout")]),v._v(")，得到节点的几何信息（位置，大小）")]),v._v(" "),e("p",[e("code",[v._v("Painting")]),v._v("(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素")]),v._v(" "),e("p",[e("code",[v._v("Display")]),v._v(": 将像素发送给"),e("code",[v._v("GPU")]),v._v("，最后通过调用操作系统"),e("code",[v._v("Native GUI")]),v._v("的"),e("code",[v._v("API")]),v._v("绘制，展示在页面上。")]),v._v(" "),e("h3",{attrs:{id:"构建dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建dom"}},[v._v("#")]),v._v(" 构建DOM")]),v._v(" "),e("p",[e("code",[v._v("字节数据")]),v._v(" -> "),e("code",[v._v("字符串")]),v._v(" -> "),e("code",[v._v("Token")]),v._v(" -> "),e("code",[v._v("Node")]),v._v(" -> "),e("code",[v._v("DOM")])]),v._v(" "),e("h3",{attrs:{id:"构建cssom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建cssom"}},[v._v("#")]),v._v(" 构建CSSOM")]),v._v(" "),e("p",[e("code",[v._v("字节数据")]),v._v(" -> "),e("code",[v._v("字符串")]),v._v(" -> "),e("code",[v._v("Token")]),v._v(" -> "),e("code",[v._v("Node")]),v._v(" -> "),e("code",[v._v("CSSOM")])]),v._v(" "),e("h2",{attrs:{id:"布局与绘制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#布局与绘制"}},[v._v("#")]),v._v(" 布局与绘制")]),v._v(" "),e("p",[v._v("当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做"),e("strong",[v._v("回流")]),v._v("）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“"),e("strong",[v._v("自动重排")]),v._v("”。")]),v._v(" "),e("p",[v._v("布局流程的输出是一个“"),e("strong",[v._v("盒模型")]),v._v("”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。")]),v._v(" "),e("p",[v._v("布局完成后，浏览器会立即发出“"),e("code",[v._v("Paint Setup")]),v._v("”和“"),e("code",[v._v("Paint")]),v._v("”事件，将渲染树转换成屏幕上的像素。")]),v._v(" "),e("h2",{attrs:{id:"回流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回流"}},[v._v("#")]),v._v(" 回流")]),v._v(" "),e("p",[v._v("前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口("),e("code",[v._v("viewport")]),v._v(")内的确切位置和大小，这个计算的阶段就是"),e("strong",[v._v("回流")]),v._v("。")]),v._v(" "),e("h2",{attrs:{id:"重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[v._v("#")]),v._v(" 重绘")]),v._v(" "),e("p",[v._v("最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做"),e("strong",[v._v("重绘节点")]),v._v("。")]),v._v(" "),e("h3",{attrs:{id:"何时发生回流重绘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#何时发生回流重绘"}},[v._v("#")]),v._v(" 何时发生回流重绘")]),v._v(" "),e("ul",[e("li",[v._v("页面一开始渲染的时候（这肯定避免不了）")]),v._v(" "),e("li",[v._v("浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）")]),v._v(" "),e("li",[v._v("添加或删除可见的DOM元素")]),v._v(" "),e("li",[v._v("元素的位置发生变化")]),v._v(" "),e("li",[v._v("元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）")]),v._v(" "),e("li",[v._v("内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。")]),v._v(" "),e("li",[v._v("元素字体大小变化")]),v._v(" "),e("li",[v._v("激活CSS伪类（例如：:hover）")]),v._v(" "),e("li",[v._v("事件\n"),e("ul",[e("li",[v._v("clientWidth、clientHeight、clientTop、clientLeft")]),v._v(" "),e("li",[v._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),v._v(" "),e("li",[v._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),v._v(" "),e("li",[v._v("scrollIntoView()、scrollIntoViewIfNeeded()")]),v._v(" "),e("li",[v._v("getComputedStyle()")]),v._v(" "),e("li",[v._v("getBoundingClientRect()")]),v._v(" "),e("li",[v._v("scrollTo()")])])])]),v._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[v._v("提示")]),v._v(" "),e("p",[e("strong",[v._v("回流一定会触发重绘，而重绘不一定会回流")])])]),v._v(" "),e("h3",{attrs:{id:"不会触发回流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不会触发回流"}},[v._v("#")]),v._v(" 不会触发回流")]),v._v(" "),e("p",[v._v("当页面中元素样式的改变并不影响它在文档流中的位置时("),e("code",[v._v("color")]),v._v("、"),e("code",[v._v("background-color")]),v._v("、"),e("code",[v._v("visibility")]),v._v(")")]),v._v(" "),e("h3",{attrs:{id:"性能影响"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能影响"}},[v._v("#")]),v._v(" 性能影响")]),v._v(" "),e("p",[v._v("回流比重绘的代价要更高")]),v._v(" "),e("h2",{attrs:{id:"gzip"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gzip"}},[v._v("#")]),v._v(" Gzip")]),v._v(" "),e("p",[e("code",[v._v("Gzip")]),v._v("是流式的压缩格式，可以做到边下载边解压。有个概念的问题，不是说"),e("code",[v._v("html")]),v._v("是"),e("code",[v._v("gzip")]),v._v("压缩后的格式，而是HTTP协议可以使用"),e("code",[v._v("gzip")]),v._v("压缩的方式来传输"),e("code",[v._v("html")]),v._v("文件。另外从显示效果上看是边下载边解析的，如果不是的话，停止下载的时候要么显示全部要么一点不显示。")]),v._v(" "),e("p",[v._v("浏览器先下载"),e("code",[v._v("html")]),v._v("，然后在内存中把"),e("code",[v._v("html")]),v._v("代码转化成"),e("code",[v._v("Dom Tree")]),v._v("，然后浏览器根据"),e("code",[v._v("Dom Tree")]),v._v("上的Node分析"),e("code",[v._v("css（sandbox modle ）")]),v._v("和"),e("code",[v._v("Images")]),v._v("【所以"),e("code",[v._v("css")]),v._v("和"),e("code",[v._v("images")]),v._v("是并行下载】，当文档下载遇到"),e("code",[v._v("js")]),v._v("时，"),e("code",[v._v("js")]),v._v("独立下载（因为在"),e("code",[v._v("js")]),v._v("中很可能存在有影响"),e("code",[v._v("Dom Tree")]),v._v("结构的代码，如"),e("code",[v._v("document.write")]),v._v(",所以浏览器设计"),e("code",[v._v("js")]),v._v("为独立进程，另：行间"),e("code",[v._v("js")]),v._v("将阻塞所有"),e("code",[v._v("html")]),v._v("代码的下载），最后浏览器完成页面渲染，形成最终的“"),e("strong",[v._v("呈现树")]),v._v("”（"),e("code",[v._v("Render Tree")]),v._v("或"),e("code",[v._v("Frame Tree")]),v._v("）。")]),v._v(" "),e("p",[e("a",{attrs:{href:"http://taligarsiel.com/Projects/howbrowserswork1.htm",target:"_blank",rel:"noopener noreferrer"}},[v._v("参考文献"),e("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=t.exports}}]);